---
title: The Making of Agor
description: Behind the scenes of building agor - from solving session context loss to creating a multiplayer platform for AI agent orchestration. Developer notes on session trees and shared environments.
date: 2025-10-25
image: '/public/screenshots/agor_for_agor.png'
---

# Working Notes on Agor (still being built)

I didn't set out to build a "platform." I wanted to stop losing the thread across agent sessions and make it easier to see what was happening without asking.

## What I was trying to fix

- Fork a context window out of a session without starting over.
- Spawn sub‑sessions with a fresh window I could introspect and post‑prompt.
- Keep a “session tree” so I could see how work branched.
- Share more than code: sometimes the worktree, ideally the running environment.
- Get visibility into how prompting actually happened, not just the final PR.

## Early ideas I kept around

- “Context nuggets” — a small graph of markdown notes you can cherry‑pick into sessions.
- Lightweight session reports I can generate and attach as metadata.
- If an agent touched a PR, inspect that conversation later and continue it with the same context window.

## Why a UI (from a CLI person)

I live in vim and terminals, but I also build interactive UIs for a living. Terminals are great until you need to answer, right now:

- What did I prompt last?
- Which branch was I on?
- What was the commit at the time?
- Did the agent sneak in another `--no-verify` twelve prompts ago?

A little product design surfaces the state you actually need while AI coding. Lists weren’t enough; location and history needed to be visible.

## The snap‑together week

- React Flow: I had a board up so quickly it’s not even funny. Seeing sessions spatially made me stop asking “where was I?” and start dragging work where it belonged.
- Ant Design (x.ant.design): amazing stuff. I know it by heart; the agent knows it even better. Tables, modals, forms — shipped faster than felt fair.
- FeathersJS: sensible services; REST + WebSocket out of the box; hooks model I could live with.
- Swagger: it took me six minutes to hook it in and have live, interactive API docs.
- Nextra: the docs website kind of wrote itself. Structure, theming, MDX — done.
- WebSockets: “just worked” for the basics. Service events broadcast, the UI felt alive with minimal glue.

If you told me a year ago this would come together at this pace, I wouldn't have believed you. I'm not sure I'd have believed an army could write this level of software in a month. Insanity. I'm honestly confused about the state of software engineering right now — in a good, disorienting way.

## The velocity part that's hard to explain

Pre-launch shipped around v0.4.x. That's backend, frontend, docs website, blogs, animated gifs, single-npm-package distribution, onboarding flow — all of it. Under a month. Most of it after-hours: 8pm to 2am sessions, coordinating multiple AI agents, shipping faster than I could track.

![Using Agor to build Agor](/public/screenshots/agor_for_agor.png)

_Building Agor with Agor: multiple parallel sessions across different zones (Analyze/plan, Code!, Done!), each working on different parts of the system simultaneously._

I know software velocity slows as complexity grows. I've lived that curve my entire career. But this foundation is _solid_ and actually extensible — not the kind of prototype you throw away. The data model makes sense. The primitives compose. The architecture breathes.

So what does this pace mean for the month ahead? The next year? If this is the _starting_ velocity, what happens when the foundation is done and we're just building _on top_ of it?

I don't have an answer yet. I just know this felt different.

## Pieces that clicked

- Worktrees as the unit of work: less branch thrash; parallelism without stepping on toes.
- Session trees: fork to parallelize, spawn to delegate; keep genealogy; don’t lose context.
- SDK‑first orchestration: Claude Code, OpenAI, Gemini via SDKs; CLIs as adapters, not the core.
- MCP self‑awareness: sessions that know where they are (board, worktree) and can nudge Agor (spawn, log, attach artifacts).
- Light real‑time: presence, cursors, comments — just enough to keep context alive.

## Where I’m unsure (on purpose)

- How much to automate with zones before it gets noisy.
- What “good” session reports look like months later (useful vs. another artifact).
- The boundary between “bring your own editor” and adding more in‑UI affordances.
- How much of the “context nuggets” idea should be manual vs. inferred.

## Now and later

Agor is the right “now” solution for me and my team — at least for some things. It reduces friction between “what I’m doing,” “where it lives,” and “who can see it while it’s happening.” At this pace, I don’t know how long any of this shape stays relevant. That’s okay. I’ll keep adjusting the shape while the work (and the tools) evolve.

If you try it, I’d love to hear where you lose the thread — and what you wish was visible exactly when you needed it.
