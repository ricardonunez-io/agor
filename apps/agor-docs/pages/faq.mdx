---
title: FAQ
description: Frequently asked questions about session forking, spawning, and Agor's multiplayer workflow
---

# FAQ

## What's a worktree?

**A worktree is an isolated working directory for a git repository** - think of it as a checkout of your repo at a specific branch or commit.

Agor uses **git worktrees** under the hood (same concept as `git worktree` command), but manages them for you automatically. When you create a worktree in Agor, it:
- Creates a git worktree in `~/.agor/worktrees/<repo>/<name>`
- Optionally creates a new branch or checks out an existing one
- Tracks metadata (issue URL, PR URL, notes)
- Associates all sessions within that worktree

### Think of a worktree as a unit of work

**Best practice**: 1 worktree = 1 issue = 1 PR = 1 feature

```
Worktree "auth-feature" (issue #123, PR #456)
├─ Working directory: ~/.agor/worktrees/myapp/auth-feature
├─ Branch: feature/oauth2-auth
└─ Sessions: All AI sessions working on this feature

Worktree "payment-integration" (issue #124, PR #457)
├─ Working directory: ~/.agor/worktrees/myapp/payment-integration
├─ Branch: feature/stripe-integration
└─ Sessions: All AI sessions working on this feature
```

Each worktree is completely isolated - changes in one don't affect the other. This lets you work on multiple features simultaneously without switching branches or stashing changes.

**Agor manages the git worktrees for you** - no need to run `git worktree add` manually. Just create a worktree in the UI or CLI, and Agor handles the git operations.

## What happens when I "fork" a session?

**IMPORTANT**: When you fork a session, you're forking the **CONTEXT WINDOW** (conversation history), NOT the git worktree.

- ✅ **Forked**: Conversation history, AI's memory of what was discussed
- ❌ **NOT forked**: Git state, filesystem, worktree

**Both sessions work on the SAME worktree.** If one session creates a file, the other session sees it immediately. This is NOT like git branches!

## Why would I fork a session?

**Forking creates a sibling session with a COPY of the conversation context at that moment** - perfect for parallel work streams that need the same starting knowledge but different focus.

After forking, the conversations diverge. The fork has its own independent conversation history going forward.

### Common use cases:

**Parallelize work that needs the same starting context**

```
Session: "Built user authentication feature" <- snapshot taken here
├─ Fork A: "Write comprehensive unit tests for auth"
├─ Fork B: "Build user profile page that uses auth"
└─ Fork C: "Generate API documentation"
```

Each fork starts with the full context of how auth works, then builds its own conversation. They work on different files so no conflicts.

**Other examples:**
- Generate reports/summaries without interrupting work
- Review or validate completed work with full context
- Get second opinions from different models

### Key insight

Forks **share the worktree** (same filesystem) but **copy the context** (snapshot at fork time, then conversations diverge).

You're not exploring alternative implementations (they'd conflict on disk!) - you're doing parallel work that starts from the same knowledge but different focus.

---

## What happens when I "spawn" a subtask?

**Spawning creates a child session** - like forking, but with parent-child hierarchy instead of siblings.

### Common use cases:

**Break down complex work**

```
Parent: "Build complete e-commerce checkout flow"
├─ Spawn: "Implement payment gateway integration"
├─ Spawn: "Build inventory validation service"
└─ Spawn: "Create order confirmation email templates"
```

**Delegate to different agents**

```
Parent (Claude): "Refactor legacy codebase"
├─ Spawn (Codex): "Write comprehensive unit tests"
├─ Spawn (Gemini): "Generate API documentation"
└─ Spawn (Claude): "Extract common utilities"
```

Parent orchestrates, children execute focused subtasks.

---

## Fork vs Spawn: Quick Reference

| | **Fork** | **Spawn** |
|---|---|---|
| **What's copied** | Context snapshot at fork time | Context snapshot at spawn time |
| **After fork** | Independent conversations that diverge | Independent conversations that diverge |
| **Worktree** | **SHARED** (same filesystem) | **SHARED** (same filesystem) |
| **Relationship** | Sibling (parallel work) | Child (delegated work) |
| **Use case** | Parallel tasks with same starting context | Break down complex work hierarchically |
| **Key constraint** | Must not conflict on disk | Must not conflict on disk |

---

## When should I fork a session vs create a new worktree?

**Different worktrees = Isolation** (different features, competing implementations, or agents that would conflict)

**Fork session = Shared worktree** (parallel work that needs same context but won't conflict)

### Use different worktrees when:

- **Working on different features/issues** - Each worktree represents a unit of work
- **Trying competing implementations** - Let Claude and Codex both implement the same feature, compare results
- **Need filesystem isolation** - Changes in one worktree don't affect the other
- **Working on different git branches** - Each worktree can be on a different branch

**Best practice**: Think of a worktree as a project or unit of work. Ideally 1 worktree = 1 issue = 1 PR. Agor lets you attach issue URLs and PR URLs to worktrees for this reason.

### Fork a session within a worktree when:

- **Parallel work on same feature** - Write tests while building the next component
- **Different aspects of same work** - Implementation, documentation, review all need same context
- **Read-only analysis** - Generate reports or summaries without interrupting main work
- **No filesystem conflicts** - Work happens in different files/directories

**Example:**

```
Worktree "auth-feature" (issue #123, PR #456)
└─ Session: "Build OAuth2 authentication"
   ├─ Fork: "Write unit tests for OAuth2"        <- Same worktree
   ├─ Fork: "Build user profile that uses auth"  <- Same worktree
   └─ Fork: "Document OAuth2 API"                <- Same worktree

Worktree "payment-feature" (issue #124, PR #457)  <- Different feature = different worktree
└─ Session: "Build Stripe integration"
```

**Rule of thumb**: If they're working on the same issue/feature and won't conflict on disk, fork the session. If they're different features or would conflict, use different worktrees.

---

## Best Practices

### ✅ DO:

- Fork for read-only analysis (summaries, reviews, documentation)
- Fork for parallel non-conflicting work (tests while building next feature)
- Spawn to break down complex work into focused tasks
- Ensure forked/spawned work won't conflict on disk (different files/directories)

### ❌ DON'T:

- **Don't fork to try alternative implementations** (they'll conflict on disk!)
- Don't forget: **forks share the worktree** - they're not git branches!
- Don't nest spawns too deeply (2-3 levels max)

---

## Summary

**What's forked**: Context window (conversation history snapshot)
**What's NOT forked**: Git worktree (shared filesystem)

**Fork** = Parallel work with same starting context (sibling sessions)
**Spawn** = Hierarchical delegation (parent-child sessions)

Both work on the **same worktree**, both start from a **copied context snapshot**, both build **independent conversations** going forward.

Example: Build Feature 1 once. Fork 3 times:
- Tests being written (with context snapshot of implementation)
- Feature 2 being built (with context snapshot of how Feature 1 works)
- Documentation being generated (with context snapshot of design decisions)

All running in parallel, same codebase, each starting from the same understanding.
