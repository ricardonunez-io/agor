/**
 * Codex Prompt Service
 *
 * Handles live execution of prompts against Codex sessions using OpenAI Codex SDK.
 * Wraps the @openai/codex-sdk for thread management and execution.
 */

import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import { Codex, type Thread, type ThreadItem } from '@openai/codex-sdk';
import type { MessagesRepository } from '../../db/repositories/messages';
import type { SessionRepository } from '../../db/repositories/sessions';
import type { CodexPermissionMode, PermissionMode, SessionID, TaskID } from '../../types';
import { DEFAULT_CODEX_MODEL } from './models';

export interface CodexPromptResult {
  /** Complete assistant response from Codex */
  messages: Array<{
    content: Array<{
      type: string;
      text?: string;
      id?: string;
      name?: string;
      input?: Record<string, unknown>;
    }>;
    toolUses?: Array<{
      id: string;
      name: string;
      input: Record<string, unknown>;
    }>;
  }>;
  /** Number of input tokens */
  inputTokens: number;
  /** Number of output tokens */
  outputTokens: number;
  /** Agent SDK thread ID for conversation continuity */
  threadId: string;
}

/**
 * Streaming event types for Codex execution
 */
export type CodexStreamEvent =
  | {
      type: 'partial';
      textChunk: string;
      threadId?: string;
      resolvedModel?: string;
    }
  | {
      type: 'tool_start';
      toolUse: {
        id: string;
        name: string;
        input: Record<string, unknown>;
      };
      threadId?: string;
    }
  | {
      type: 'tool_complete';
      toolUse: {
        id: string;
        name: string;
        input: Record<string, unknown>;
        output?: string;
        status?: string;
      };
      threadId?: string;
    }
  | {
      type: 'complete';
      content: Array<{
        type: string;
        text?: string;
        id?: string;
        name?: string;
        input?: Record<string, unknown>;
      }>;
      toolUses?: Array<{
        id: string;
        name: string;
        input: Record<string, unknown>;
      }>;
      threadId: string;
      resolvedModel?: string;
    };

export class CodexPromptService {
  private codex: Codex;
  private lastApprovalPolicy: string | null = null;
  private stopRequested = new Map<SessionID, boolean>();

  constructor(
    _messagesRepo: MessagesRepository,
    private sessionsRepo: SessionRepository,
    apiKey?: string
  ) {
    // Initialize Codex SDK
    this.codex = new Codex({
      apiKey: apiKey || process.env.OPENAI_API_KEY,
    });
  }

  /**
   * Generate ~/.codex/config.toml for approval_policy setting
   *
   * NOTE: approval_policy cannot be passed via ThreadOptions, so we must use config.toml.
   * We minimize file writes by tracking the last set value and only updating when it changes.
   */
  private async ensureApprovalPolicy(permissionMode: CodexPermissionMode): Promise<void> {
    const approvalPolicyMap: Record<CodexPermissionMode, string> = {
      ask: 'untrusted', // Ask before running any command
      auto: 'on-request', // Model decides when to ask (recommended)
      'on-failure': 'on-failure', // Ask only when commands fail
      'allow-all': 'never', // Never ask, auto-approve all operations
    };

    const approvalPolicy = approvalPolicyMap[permissionMode];

    // Skip if already set to this value (avoid unnecessary file I/O)
    if (this.lastApprovalPolicy === approvalPolicy) {
      return;
    }

    const homeDir = process.env.HOME || process.env.USERPROFILE;
    if (!homeDir) {
      console.warn('‚ö†Ô∏è  Could not determine home directory, skipping approval_policy config');
      return;
    }

    const codexConfigDir = path.join(homeDir, '.codex');
    const configPath = path.join(codexConfigDir, 'config.toml');

    const configContent = `# Codex configuration (approval_policy only - sandboxMode passed via SDK)
# Generated by Agor - ${new Date().toISOString()}

# Approval policy controls when Codex asks before running commands
# Options: "untrusted", "on-request", "on-failure", "never"
approval_policy = "${approvalPolicy}"
`;

    await fs.mkdir(codexConfigDir, { recursive: true });
    await fs.writeFile(configPath, configContent, 'utf-8');

    this.lastApprovalPolicy = approvalPolicy;
    console.log(`üìù [Codex] Set approval_policy = "${approvalPolicy}" in ~/.codex/config.toml`);
  }

  /**
   * Convert Codex item to ToolUse format
   * Maps different Codex item types to Agor tool use schema
   */
  private itemToToolUse(
    item: ThreadItem,
    status: 'started' | 'completed'
  ): {
    id: string;
    name: string;
    input: Record<string, unknown>;
    output?: string;
    status?: string;
  } | null {
    switch (item.type) {
      case 'command_execution':
        return {
          id: item.id,
          name: 'bash',
          input: { command: item.command },
          ...(status === 'completed' && {
            output: item.aggregated_output || '',
            status: item.status,
          }),
        };
      case 'file_change':
        return {
          id: item.id,
          name: 'edit_files',
          input: {
            changes: item.changes || [],
          },
          ...(status === 'completed' && {
            status: item.status,
          }),
        };
      case 'mcp_tool_call':
        return {
          id: item.id,
          name: `${item.server}.${item.tool}`,
          input: {},
          ...(status === 'completed' && {
            status: item.status,
          }),
        };
      case 'web_search':
        return {
          id: item.id,
          name: 'web_search',
          input: { query: item.query },
        };
      case 'reasoning':
        // Don't emit tool use for reasoning (it's internal)
        return null;
      case 'todo_list':
        // Don't emit tool use for todo list (it's internal)
        return null;
      case 'agent_message':
        // Don't emit tool use for text messages
        return null;
      default:
        return null;
    }
  }

  /**
   * Execute prompt with streaming support
   *
   * Uses Codex SDK's runStreamed() method for real-time event streaming.
   * Yields partial text chunks and complete messages.
   *
   * @param sessionId - Agor session ID
   * @param prompt - User prompt
   * @param taskId - Optional task ID
   * @param permissionMode - Permission mode for tool execution ('ask' | 'auto' | 'allow-all')
   * @returns Async generator of streaming events
   */
  async *promptSessionStreaming(
    sessionId: SessionID,
    prompt: string,
    _taskId?: TaskID,
    permissionMode?: PermissionMode
  ): AsyncGenerator<CodexStreamEvent> {
    // Get session to check for existing thread ID and working directory
    const session = await this.sessionsRepo.findById(sessionId);
    if (!session) {
      throw new Error(`Session ${sessionId} not found`);
    }

    console.log(`üîç [Codex] Starting prompt execution for session ${sessionId.substring(0, 8)}`);
    console.log(`   Working directory: ${session.repo.cwd}`);
    console.log(`   Permission mode: ${permissionMode || 'not specified (will use default)'}`);
    console.log(`   Existing thread ID: ${session.sdk_session_id || 'none (will create new)'}`);

    // Determine effective permission mode (default to 'auto' for Codex)
    const effectivePermissionMode = (permissionMode ||
      session.permission_config?.mode ||
      'auto') as CodexPermissionMode;

    // HYBRID APPROACH: Codex permissions require TWO settings:
    // 1. sandboxMode (via ThreadOptions) - controls WHERE you can write
    // 2. approval_policy (via config.toml) - controls WHETHER agent asks before executing

    // Map Agor permission modes to Codex SDK SandboxMode (passed via ThreadOptions)
    const sandboxModeMap: Record<
      CodexPermissionMode,
      'read-only' | 'workspace-write' | 'danger-full-access'
    > = {
      ask: 'read-only',
      auto: 'workspace-write',
      'on-failure': 'workspace-write',
      'allow-all': 'workspace-write',
    };
    const sandboxMode = sandboxModeMap[effectivePermissionMode];

    // Set approval_policy in config.toml (required because it's not available in ThreadOptions)
    await this.ensureApprovalPolicy(effectivePermissionMode);

    console.log(`   Configured: sandboxMode=${sandboxMode}, approval_policy via config.toml`);

    // Build thread options with sandbox mode
    const threadOptions = {
      workingDirectory: session.repo.cwd,
      skipGitRepoCheck: false,
      sandboxMode,
    };

    // Check if we need to update thread settings due to permission mode change
    const sessionPermissionMode = session.permission_config?.mode || 'auto';
    const permissionModeChanged = effectivePermissionMode !== sessionPermissionMode;

    // Start or resume thread
    let thread: Thread;
    if (session.sdk_session_id) {
      console.log(`üîÑ [Codex] Resuming thread: ${session.sdk_session_id}`);
      thread = this.codex.resumeThread(session.sdk_session_id, threadOptions);

      // If permission mode changed, send slash commands to update thread settings
      if (permissionModeChanged) {
        console.log(
          `‚öôÔ∏è  [Codex] Permission mode changed: ${sessionPermissionMode} ‚Üí ${effectivePermissionMode}`
        );
        console.log(`   Sending slash commands to update thread settings...`);

        // Map permission modes to Codex CLI slash command parameters
        const approvalModeMap: Record<CodexPermissionMode, string> = {
          ask: 'untrusted',
          auto: 'on-request',
          'on-failure': 'on-failure',
          'allow-all': 'never',
        };
        const approvalMode = approvalModeMap[effectivePermissionMode];

        // Send /approvals command to change approval policy mid-conversation
        // Note: sandboxMode is already updated via ThreadOptions on resumeThread()
        const slashCommand = `/approvals ${approvalMode}`;
        console.log(`   Executing: ${slashCommand}`);

        try {
          // Send the slash command and consume the response
          await thread.run(slashCommand);
          console.log(`‚úÖ [Codex] Thread settings updated successfully`);
        } catch (error) {
          console.error(`‚ùå [Codex] Failed to update thread settings:`, error);
          // Continue anyway - the user's prompt will still be sent
        }
      }
    } else {
      console.log(`üÜï [Codex] Creating new thread`);
      thread = this.codex.startThread(threadOptions);
    }

    try {
      console.log(
        `‚ñ∂Ô∏è  [Codex] Running prompt: "${prompt.substring(0, 50)}${prompt.length > 50 ? '...' : ''}"`
      );

      // Use streaming API
      const { events } = await thread.runStreamed(prompt);

      let currentMessage: Array<{
        type: string;
        text?: string;
        id?: string;
        name?: string;
        input?: Record<string, unknown>;
        tool_use_id?: string;
        content?: string;
        is_error?: boolean;
      }> = [];
      let threadId = session.sdk_session_id || '';
      let resolvedModel: string | undefined;
      let previousText = ''; // Track previous text to emit only diffs
      let allToolUses: Array<{ id: string; name: string; input: Record<string, unknown> }> = [];

      for await (const event of events) {
        // Check if stop was requested
        if (this.stopRequested.get(sessionId)) {
          console.log(`üõë Stop requested for session ${sessionId}, breaking event loop`);
          this.stopRequested.delete(sessionId);
          break;
        }

        // Log ALL events to understand what we're getting
        console.debug('üîî Codex event type:', event.type, 'keys:', Object.keys(event));

        switch (event.type) {
          case 'turn.started':
            console.debug('üîÑ Codex turn started');
            previousText = ''; // Reset on new turn
            allToolUses = []; // Reset tool uses
            break;

          case 'item.started':
            // Emit tool_start events for tool items
            if (event.item) {
              console.debug('‚ñ∂Ô∏è  Codex item started:', event.item.type, event.item.id);

              const toolUseStart = this.itemToToolUse(event.item, 'started');
              if (toolUseStart) {
                yield {
                  type: 'tool_start',
                  toolUse: toolUseStart,
                  threadId: thread.id || undefined,
                };
              }
            }
            break;

          case 'item.updated':
            // Extract text chunks from item updates
            // IMPORTANT: event.item.text is the FULL accumulated text, not a chunk!
            // We need to emit only the new portion (diff from previous)
            console.debug('üîî Codex item.updated:', {
              itemType: event.item?.type,
              hasText: event.item && 'text' in event.item,
              textLength:
                event.item && 'text' in event.item ? (event.item.text as string).length : 0,
              previousLength: previousText.length,
            });

            // Only stream agent_message items (not command_execution, file_change, etc.)
            if (
              event.item &&
              event.item.type === 'agent_message' &&
              'text' in event.item &&
              event.item.text
            ) {
              const fullText = event.item.text as string;
              if (fullText.length > previousText.length) {
                const textChunk = fullText.substring(previousText.length);
                previousText = fullText;
                console.debug(`üì° Streaming agent_message chunk (${textChunk.length} chars)`);
                yield {
                  type: 'partial',
                  textChunk,
                  threadId: thread.id || undefined,
                  resolvedModel,
                };
              }
            }
            break;

          case 'item.completed':
            // Collect completed items and emit tool_complete events
            if (event.item) {
              console.debug('‚úÖ Codex item completed:', event.item.type, event.item.id);

              // Emit tool_complete for tool items
              const toolUseComplete = this.itemToToolUse(event.item, 'completed');
              if (toolUseComplete) {
                // Add to allToolUses for backward compatibility (tool_uses field)
                allToolUses.push({
                  id: toolUseComplete.id,
                  name: toolUseComplete.name,
                  input: toolUseComplete.input,
                });

                // Add tool_use block to content array (for UI rendering)
                currentMessage.push({
                  type: 'tool_use',
                  id: toolUseComplete.id,
                  name: toolUseComplete.name,
                  input: toolUseComplete.input,
                });

                // Add tool_result block if we have output (for UI rendering)
                if (toolUseComplete.output !== undefined || toolUseComplete.status) {
                  const isError =
                    toolUseComplete.status === 'failed' || toolUseComplete.status === 'error';
                  currentMessage.push({
                    type: 'tool_result',
                    tool_use_id: toolUseComplete.id,
                    content: toolUseComplete.output || '',
                    is_error: isError,
                  });
                }

                yield {
                  type: 'tool_complete',
                  toolUse: toolUseComplete,
                  threadId: thread.id || undefined,
                };
              }

              // Store text items for final message
              if ('text' in event.item && event.item.type === 'agent_message') {
                currentMessage.push({
                  type: 'text',
                  text: event.item.text as string,
                });
              }
            }
            break;

          case 'turn.completed': {
            // Turn complete, emit final message
            console.debug('‚úÖ Codex turn completed');
            threadId = thread.id || '';

            // Extract token usage if available
            const inputTokens = event.usage?.input_tokens || 0;
            const outputTokens = event.usage?.output_tokens || 0;
            console.debug(`üìä Tokens: ${inputTokens} input, ${outputTokens} output`);
            console.debug(`üîß Tool uses: ${allToolUses.length}`);

            // Yield complete message with all tool uses
            yield {
              type: 'complete',
              content: currentMessage,
              toolUses: allToolUses.length > 0 ? allToolUses : undefined,
              threadId,
              resolvedModel: resolvedModel || DEFAULT_CODEX_MODEL,
            };

            // Reset for next message
            currentMessage = [];
            allToolUses = [];
            break;
          }

          case 'turn.failed':
            console.error('‚ùå Codex turn failed:', event.error);
            throw new Error(`Codex execution failed: ${event.error}`);

          default:
            console.debug('üîî Codex event:', event.type);
        }
      }
    } catch (error) {
      console.error('‚ùå Codex streaming error:', error);
      throw error;
    }
  }

  /**
   * Execute prompt (non-streaming version)
   *
   * Collects all streaming events and returns complete result.
   *
   * @param sessionId - Agor session ID
   * @param prompt - User prompt
   * @param taskId - Optional task ID
   * @param permissionMode - Permission mode for tool execution ('ask' | 'auto' | 'allow-all')
   * @returns Complete prompt result
   */
  async promptSession(
    sessionId: SessionID,
    prompt: string,
    taskId?: TaskID,
    permissionMode?: PermissionMode
  ): Promise<CodexPromptResult> {
    const messages: CodexPromptResult['messages'] = [];
    let threadId = '';
    const inputTokens = 0;
    const outputTokens = 0;

    for await (const event of this.promptSessionStreaming(
      sessionId,
      prompt,
      taskId,
      permissionMode
    )) {
      if (event.type === 'complete') {
        messages.push({
          content: event.content,
          toolUses: event.toolUses,
        });
        threadId = event.threadId;
      }
      // Skip partial events in non-streaming mode
    }

    return {
      messages,
      inputTokens,
      outputTokens,
      threadId,
    };
  }

  /**
   * Stop currently executing task
   *
   * Sets a stop flag that is checked in the event loop.
   * The loop will break on the next iteration, stopping execution gracefully.
   *
   * @param sessionId - Session identifier
   * @returns Success status
   */
  stopTask(sessionId: SessionID): { success: boolean; reason?: string } {
    // Set stop flag
    this.stopRequested.set(sessionId, true);
    console.log(`üõë Stop requested for Codex session ${sessionId}`);

    return { success: true };
  }
}
