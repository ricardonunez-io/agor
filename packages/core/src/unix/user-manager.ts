/**
 * Unix User Management Utilities
 *
 * Provides utilities for managing Unix users for Agor.
 * Users follow the naming convention: agor_<short-id> or custom unix_username.
 *
 * @see context/guides/rbac-and-unix-isolation.md
 */

import { execSync } from 'node:child_process';
import { formatShortId } from '../lib/ids.js';
import type { UserID, UUID } from '../types/index.js';

/**
 * Default home directory base for Agor users
 */
export const AGOR_HOME_BASE = '/home';

/**
 * Default shell for new Agor users
 */
export const AGOR_DEFAULT_SHELL = '/bin/bash';

/**
 * Agor worktrees directory name within user home
 */
export const AGOR_WORKTREES_DIR = 'agor/worktrees';

/**
 * Generate a default Unix username for an Agor user
 *
 * Format: agor_<short-id>
 * Example: agor_03b62447
 *
 * @param userId - Full user UUID
 * @returns Unix username (e.g., 'agor_03b62447')
 */
export function generateUnixUsername(userId: UserID): string {
  const shortId = formatShortId(userId as UUID);
  return `agor_${shortId}`;
}

/**
 * Parse user short ID from Unix username
 *
 * @param username - Unix username (e.g., 'agor_03b62447')
 * @returns Short user ID (8 chars) or null if not an auto-generated name
 */
export function parseUnixUsername(username: string): string | null {
  const match = username.match(/^agor_([0-9a-f]{8})$/);
  return match ? match[1] : null;
}

/**
 * Check if username follows Agor auto-generated format
 *
 * @param username - Username to validate
 * @returns true if matches agor_<8-hex-chars> format
 */
export function isAutoGeneratedUsername(username: string): boolean {
  return /^agor_[0-9a-f]{8}$/.test(username);
}

/**
 * Validate Unix username format
 *
 * Unix usernames must:
 * - Start with lowercase letter or underscore
 * - Contain only lowercase letters, digits, underscores, hyphens
 * - Be 1-32 characters long
 *
 * @param username - Username to validate
 * @returns true if valid Unix username
 */
export function isValidUnixUsername(username: string): boolean {
  return /^[a-z_][a-z0-9_-]{0,31}$/.test(username);
}

/**
 * Get home directory path for a Unix user
 *
 * @param username - Unix username
 * @param homeBase - Base directory for homes (default: /home)
 * @returns Full home directory path
 */
export function getUserHomeDir(username: string, homeBase: string = AGOR_HOME_BASE): string {
  return `${homeBase}/${username}`;
}

/**
 * Get Agor worktrees directory path for a user
 *
 * @param username - Unix username
 * @param homeBase - Base directory for homes (default: /home)
 * @returns Full path to ~/agor/worktrees
 */
export function getUserWorktreesDir(username: string, homeBase: string = AGOR_HOME_BASE): string {
  return `${homeBase}/${username}/${AGOR_WORKTREES_DIR}`;
}

/**
 * Unix user management commands (to be executed via sudo)
 *
 * These are shell command strings for privileged user operations.
 */
export const UnixUserCommands = {
  /**
   * Check if a Unix user exists
   *
   * @param username - Unix username
   * @returns Command string (exits 0 if exists, non-zero if not)
   */
  userExists: (username: string) => `id "${username}" > /dev/null 2>&1`,

  /**
   * Create a new Unix user with home directory
   *
   * @param username - Unix username to create
   * @param shell - Login shell (default: /bin/bash)
   * @param homeBase - Base directory for home (default: /home)
   * @returns Command string
   */
  createUser: (
    username: string,
    shell: string = AGOR_DEFAULT_SHELL,
    homeBase: string = AGOR_HOME_BASE
  ) => `sudo -n useradd -m -d "${homeBase}/${username}" -s "${shell}" "${username}"`,

  /**
   * Create user with specific UID/GID
   *
   * @param username - Unix username
   * @param uid - User ID
   * @param gid - Group ID (optional, defaults to uid)
   * @param shell - Login shell
   * @param homeBase - Home directory base
   * @returns Command string
   */
  createUserWithId: (
    username: string,
    uid: number,
    gid?: number,
    shell: string = AGOR_DEFAULT_SHELL,
    homeBase: string = AGOR_HOME_BASE
  ) => {
    const gidArg = gid !== undefined ? `-g ${gid}` : '';
    return `sudo -n useradd -m -d "${homeBase}/${username}" -s "${shell}" -u ${uid} ${gidArg} "${username}"`;
  },

  /**
   * Delete a Unix user (keeps home directory)
   *
   * @param username - Unix username to delete
   * @returns Command string
   */
  deleteUser: (username: string) => `sudo -n userdel "${username}"`,

  /**
   * Get command array for setting Unix user password via chpasswd
   *
   * SECURITY: This returns a command array to be used with execWithInput().
   * The password MUST be passed via stdin (not command-line arguments) to avoid:
   * 1. Command injection vulnerabilities (shell metacharacters in password)
   * 2. Password exposure in process listings (ps aux)
   * 3. Password exposure in shell history
   *
   * Format for stdin: "username:password\n"
   *
   * @returns Command array for execWithInput: ['chpasswd']
   *
   * @example
   * ```ts
   * const cmd = UnixUserCommands.setPasswordCommand();
   * await executor.execWithInput(cmd, { input: `${username}:${password}\n` });
   * ```
   */
  setPasswordCommand: (): string[] => {
    return ['chpasswd'];
  },

  /**
   * Format stdin input for chpasswd command
   *
   * @param username - Unix username
   * @param password - Plaintext password to set
   * @returns Formatted stdin input: "username:password\n"
   */
  formatPasswordInput: (username: string, password: string): string => {
    return `${username}:${password}\n`;
  },

  /**
   * Delete a Unix user and their home directory
   *
   * @param username - Unix username to delete
   * @returns Command string
   */
  deleteUserWithHome: (username: string) => `sudo -n userdel -r "${username}"`,

  /**
   * Lock a Unix user account (disable login)
   *
   * @param username - Unix username
   * @returns Command string
   */
  lockUser: (username: string) => `sudo -n usermod -L "${username}"`,

  /**
   * Unlock a Unix user account
   *
   * @param username - Unix username
   * @returns Command string
   */
  unlockUser: (username: string) => `sudo -n usermod -U "${username}"`,

  /**
   * Get user's UID
   *
   * @param username - Unix username
   * @returns Command string (outputs UID)
   */
  getUserUid: (username: string) => `id -u "${username}"`,

  /**
   * Get user's primary GID
   *
   * @param username - Unix username
   * @returns Command string (outputs GID)
   */
  getUserGid: (username: string) => `id -g "${username}"`,

  /**
   * Get all groups a user belongs to
   *
   * @param username - Unix username
   * @returns Command string (outputs space-separated group names)
   */
  getUserGroups: (username: string) => `id -nG "${username}"`,

  /**
   * Create directory with proper ownership
   *
   * Returns an array of commands to be executed sequentially.
   * Commands include sudo -n and can be run directly.
   *
   * @param path - Directory path to create
   * @param username - Owner username
   * @param group - Owner group (defaults to username)
   * @param mode - Permission mode (default: 755)
   * @returns Array of command strings to execute sequentially
   */
  createOwnedDirectory: (
    path: string,
    username: string,
    group?: string,
    mode: string = '755'
  ): string[] => {
    const grp = group || username;
    return [
      `sudo -n mkdir -p "${path}"`,
      `sudo -n chown "${username}:${grp}" "${path}"`,
      `sudo -n chmod ${mode} "${path}"`,
    ];
  },

  /**
   * Setup Agor worktrees directory structure for a user
   *
   * Creates ~/agor/worktrees with proper ownership.
   * Returns an array of commands to be executed sequentially.
   *
   * @param username - Unix username
   * @param homeBase - Home directory base
   * @returns Array of command strings to execute sequentially
   */
  setupWorktreesDir: (username: string, homeBase: string = AGOR_HOME_BASE): string[] => {
    const worktreesDir = `${homeBase}/${username}/${AGOR_WORKTREES_DIR}`;
    return [
      `sudo -n mkdir -p "${worktreesDir}"`,
      `sudo -n chown -R "${username}:${username}" "${homeBase}/${username}/agor"`,
    ];
  },
} as const;

/**
 * Error thrown when attempting to impersonate a non-existent Unix user
 */
export class UnixUserNotFoundError extends Error {
  constructor(
    public readonly username: string,
    message?: string
  ) {
    super(message ?? `Unix user "${username}" does not exist on this system`);
    this.name = 'UnixUserNotFoundError';
  }
}

/**
 * Check if a Unix user exists on the system
 *
 * @param username - Unix username to check
 * @returns true if user exists
 */
export function unixUserExists(username: string): boolean {
  try {
    execSync(`id "${username}" > /dev/null 2>&1`, { stdio: 'pipe' });
    return true;
  } catch {
    return false;
  }
}

/**
 * Unix user mode types
 */
export type UnixUserMode = 'simple' | 'insulated' | 'strict';

/**
 * Result of resolving which Unix user to impersonate
 */
export interface ImpersonationResult {
  /** Unix username to impersonate, or null for no impersonation */
  unixUser: string | null;
  /** Human-readable reason for the decision */
  reason: string;
}

/**
 * Options for resolving Unix user impersonation
 */
export interface ResolveImpersonationOptions {
  /** Unix user mode from config */
  mode: UnixUserMode;
  /** User's unix_username (from authenticated user or session creator) */
  userUnixUsername?: string | null;
  /** Fallback executor user from config */
  executorUnixUser?: string | null;
}

/**
 * Resolve which Unix user to impersonate based on mode and available users
 *
 * This is the central logic for determining impersonation across:
 * - Terminal sessions (uses authenticated user's unix_username)
 * - Executor spawning (uses session's unix_username)
 *
 * @param options - Resolution options
 * @returns ImpersonationResult with user and reason
 * @throws Error if strict mode and no unix_username provided
 *
 * @example
 * ```ts
 * const result = resolveUnixUserForImpersonation({
 *   mode: 'strict',
 *   userUnixUsername: 'alice',
 * });
 * // result.unixUser = 'alice' (throws if alice doesn't exist)
 * ```
 */
export function resolveUnixUserForImpersonation(
  options: ResolveImpersonationOptions
): ImpersonationResult {
  const { mode, userUnixUsername, executorUnixUser } = options;

  switch (mode) {
    case 'simple':
      // No impersonation - run as current user
      return {
        unixUser: null,
        reason: 'simple mode - no impersonation',
      };

    case 'insulated':
      // Always use executor user from config
      return {
        unixUser: executorUnixUser ?? null,
        reason: executorUnixUser
          ? `insulated mode - using executor: ${executorUnixUser}`
          : 'insulated mode - no executor configured',
      };

    case 'strict':
      // Require user's unix_username, fail if not set
      if (!userUnixUsername) {
        throw new Error(
          'Strict Unix user mode requires unix_username to be set. ' +
            'Ensure the user has a unix_username configured.'
        );
      }
      return {
        unixUser: userUnixUsername,
        reason: `strict mode - using unix_username: ${userUnixUsername}`,
      };

    default:
      console.warn(`⚠️ Unknown unix_user_mode: ${mode}, falling back to simple mode`);
      return {
        unixUser: null,
        reason: 'unknown mode - defaulting to no impersonation',
      };
  }
}

/**
 * Validate that a resolved Unix user exists (for strict/insulated modes)
 *
 * Call this after resolveUnixUserForImpersonation for modes that require validation.
 *
 * @param mode - Unix user mode
 * @param unixUser - Resolved Unix user (from resolveUnixUserForImpersonation)
 * @throws Error with user-friendly message if user doesn't exist
 */
export function validateResolvedUnixUser(mode: UnixUserMode, unixUser: string | null): void {
  // Only validate for strict/insulated modes
  if ((mode === 'strict' || mode === 'insulated') && unixUser) {
    if (!unixUserExists(unixUser)) {
      throw new UnixUserNotFoundError(
        unixUser,
        `${mode === 'strict' ? 'Strict' : 'Insulated'} Unix user mode: ` +
          `user "${unixUser}" does not exist on this system. ` +
          'Ensure the Unix user is created first.'
      );
    }
  }
}
