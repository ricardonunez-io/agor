/**
 * Tests for Unix User Management Utilities
 *
 * These tests cover:
 * - Username generation and parsing
 * - Username validation
 * - Path generation
 * - Command string builders
 * - Impersonation resolution logic
 */

import { beforeEach, describe, expect, it, vi } from 'vitest';
import type { UserID } from '../types/index.js';
import {
  AGOR_DEFAULT_SHELL,
  AGOR_HOME_BASE,
  AGOR_WORKTREES_DIR,
  generateUnixUsername,
  getUserHomeDir,
  getUserWorktreesDir,
  isAutoGeneratedUsername,
  isValidUnixUsername,
  parseUnixUsername,
  resolveUnixUserForImpersonation,
  UnixUserCommands,
  UnixUserNotFoundError,
  validateResolvedUnixUser,
} from './user-manager.js';

// Mock execSync for system-dependent tests
vi.mock('node:child_process', () => ({
  execSync: vi.fn(),
}));

import { execSync } from 'node:child_process';

const mockedExecSync = vi.mocked(execSync);

describe('user-manager', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  // =========================================================================
  // Username Generation
  // =========================================================================

  describe('generateUnixUsername', () => {
    it('generates username from UUID with agor_ prefix', () => {
      const userId = '01234567-89ab-cdef-0123-456789abcdef' as UserID;
      const username = generateUnixUsername(userId);
      expect(username).toBe('agor_01234567');
    });

    it('uses first 8 chars of UUID as short ID', () => {
      const userId = 'abcdef01-2345-6789-abcd-ef0123456789' as UserID;
      const username = generateUnixUsername(userId);
      expect(username).toBe('agor_abcdef01');
    });

    it('handles UUIDv7 format correctly', () => {
      // UUIDv7 starts with timestamp, so first 8 chars are timestamp-based
      const userId = '019377a4-5c3b-7def-8abc-123456789abc' as UserID;
      const username = generateUnixUsername(userId);
      expect(username).toBe('agor_019377a4');
    });
  });

  // =========================================================================
  // Username Parsing
  // =========================================================================

  describe('parseUnixUsername', () => {
    it('extracts short ID from valid auto-generated username', () => {
      expect(parseUnixUsername('agor_01234567')).toBe('01234567');
      expect(parseUnixUsername('agor_abcdef01')).toBe('abcdef01');
    });

    it('returns null for non-agor usernames', () => {
      expect(parseUnixUsername('alice')).toBeNull();
      expect(parseUnixUsername('root')).toBeNull();
      expect(parseUnixUsername('admin_01234567')).toBeNull();
    });

    it('returns null for invalid agor username formats', () => {
      expect(parseUnixUsername('agor_')).toBeNull(); // too short
      expect(parseUnixUsername('agor_1234567')).toBeNull(); // 7 chars
      expect(parseUnixUsername('agor_123456789')).toBeNull(); // 9 chars
      expect(parseUnixUsername('agor_ABCDEF01')).toBeNull(); // uppercase
      expect(parseUnixUsername('agor_1234567g')).toBeNull(); // invalid hex
    });

    it('returns null for custom unix usernames', () => {
      expect(parseUnixUsername('alice_dev')).toBeNull();
      expect(parseUnixUsername('agor_executor')).toBeNull(); // not 8 hex chars
    });
  });

  // =========================================================================
  // Username Validation
  // =========================================================================

  describe('isAutoGeneratedUsername', () => {
    it('returns true for valid auto-generated usernames', () => {
      expect(isAutoGeneratedUsername('agor_01234567')).toBe(true);
      expect(isAutoGeneratedUsername('agor_abcdef01')).toBe(true);
      expect(isAutoGeneratedUsername('agor_00000000')).toBe(true);
      expect(isAutoGeneratedUsername('agor_ffffffff')).toBe(true);
    });

    it('returns false for custom usernames', () => {
      expect(isAutoGeneratedUsername('alice')).toBe(false);
      expect(isAutoGeneratedUsername('agor_executor')).toBe(false);
      expect(isAutoGeneratedUsername('agor_admin')).toBe(false);
    });

    it('returns false for invalid formats', () => {
      expect(isAutoGeneratedUsername('agor_ABCDEF01')).toBe(false); // uppercase
      expect(isAutoGeneratedUsername('agor_1234567')).toBe(false); // 7 chars
      expect(isAutoGeneratedUsername('agor_123456789')).toBe(false); // 9 chars
    });
  });

  describe('isValidUnixUsername', () => {
    it('accepts valid usernames starting with lowercase letter', () => {
      expect(isValidUnixUsername('alice')).toBe(true);
      expect(isValidUnixUsername('bob123')).toBe(true);
      expect(isValidUnixUsername('user_name')).toBe(true);
      expect(isValidUnixUsername('user-name')).toBe(true);
    });

    it('accepts usernames starting with underscore', () => {
      expect(isValidUnixUsername('_system')).toBe(true);
      expect(isValidUnixUsername('_agor')).toBe(true);
    });

    it('accepts agor-generated usernames', () => {
      expect(isValidUnixUsername('agor_01234567')).toBe(true);
      expect(isValidUnixUsername('agor_executor')).toBe(true);
    });

    it('rejects usernames starting with uppercase', () => {
      expect(isValidUnixUsername('Alice')).toBe(false);
      expect(isValidUnixUsername('ADMIN')).toBe(false);
    });

    it('rejects usernames starting with numbers', () => {
      expect(isValidUnixUsername('1user')).toBe(false);
      expect(isValidUnixUsername('123')).toBe(false);
    });

    it('rejects usernames with invalid characters', () => {
      expect(isValidUnixUsername('user.name')).toBe(false); // dot
      expect(isValidUnixUsername('user@domain')).toBe(false); // at
      expect(isValidUnixUsername('user name')).toBe(false); // space
      expect(isValidUnixUsername('user$var')).toBe(false); // dollar
    });

    it('rejects empty usernames', () => {
      expect(isValidUnixUsername('')).toBe(false);
    });

    it('rejects usernames longer than 32 characters', () => {
      expect(isValidUnixUsername('a'.repeat(32))).toBe(true); // exactly 32
      expect(isValidUnixUsername('a'.repeat(33))).toBe(false); // 33
    });
  });

  // =========================================================================
  // Path Generation
  // =========================================================================

  describe('getUserHomeDir', () => {
    it('returns home directory path with default base', () => {
      expect(getUserHomeDir('alice')).toBe('/home/alice');
      expect(getUserHomeDir('agor_01234567')).toBe('/home/agor_01234567');
    });

    it('uses custom home base', () => {
      expect(getUserHomeDir('alice', '/users')).toBe('/users/alice');
      expect(getUserHomeDir('bob', '/var/home')).toBe('/var/home/bob');
    });
  });

  describe('getUserWorktreesDir', () => {
    it('returns worktrees directory path', () => {
      expect(getUserWorktreesDir('alice')).toBe('/home/alice/agor/worktrees');
    });

    it('uses custom home base', () => {
      expect(getUserWorktreesDir('alice', '/users')).toBe('/users/alice/agor/worktrees');
    });
  });

  // =========================================================================
  // Command Builders
  // =========================================================================

  describe('UnixUserCommands', () => {
    describe('userExists', () => {
      it('generates correct id command', () => {
        expect(UnixUserCommands.userExists('alice')).toBe('id "alice" > /dev/null 2>&1');
      });

      it('properly quotes usernames with special chars', () => {
        // Should still work with quotes - shell will handle it
        expect(UnixUserCommands.userExists('agor_01234567')).toBe(
          'id "agor_01234567" > /dev/null 2>&1'
        );
      });
    });

    describe('createUser', () => {
      it('generates useradd command with defaults', () => {
        const cmd = UnixUserCommands.createUser('alice');
        expect(cmd).toBe('useradd -m -d "/home/alice" -s "/bin/bash" "alice"');
      });

      it('uses custom shell and home base', () => {
        const cmd = UnixUserCommands.createUser('alice', '/bin/zsh', '/users');
        expect(cmd).toBe('useradd -m -d "/users/alice" -s "/bin/zsh" "alice"');
      });
    });

    describe('createUserWithId', () => {
      it('generates useradd with UID', () => {
        const cmd = UnixUserCommands.createUserWithId('alice', 1001);
        expect(cmd).toBe('useradd -m -d "/home/alice" -s "/bin/bash" -u 1001  "alice"');
      });

      it('includes GID when provided', () => {
        const cmd = UnixUserCommands.createUserWithId('alice', 1001, 1001);
        expect(cmd).toBe('useradd -m -d "/home/alice" -s "/bin/bash" -u 1001 -g 1001 "alice"');
      });
    });

    describe('deleteUser', () => {
      it('generates userdel command (keep home)', () => {
        expect(UnixUserCommands.deleteUser('alice')).toBe('userdel "alice"');
      });
    });

    describe('deleteUserWithHome', () => {
      it('generates userdel -r command', () => {
        expect(UnixUserCommands.deleteUserWithHome('alice')).toBe('userdel -r "alice"');
      });
    });

    describe('lockUser / unlockUser', () => {
      it('generates lock command', () => {
        expect(UnixUserCommands.lockUser('alice')).toBe('usermod -L "alice"');
      });

      it('generates unlock command', () => {
        expect(UnixUserCommands.unlockUser('alice')).toBe('usermod -U "alice"');
      });
    });

    describe('getUserUid / getUserGid', () => {
      it('generates id -u command', () => {
        expect(UnixUserCommands.getUserUid('alice')).toBe('id -u "alice"');
      });

      it('generates id -g command', () => {
        expect(UnixUserCommands.getUserGid('alice')).toBe('id -g "alice"');
      });
    });

    describe('createOwnedDirectory', () => {
      it('returns array of mkdir + chown + chmod commands', () => {
        const cmds = UnixUserCommands.createOwnedDirectory('/data/project', 'alice');
        expect(cmds).toEqual([
          'mkdir -p "/data/project"',
          'chown "alice:alice" "/data/project"',
          'chmod 755 "/data/project"',
        ]);
      });

      it('uses custom group and mode', () => {
        const cmds = UnixUserCommands.createOwnedDirectory(
          '/data/shared',
          'alice',
          'developers',
          '775'
        );
        expect(cmds).toEqual([
          'mkdir -p "/data/shared"',
          'chown "alice:developers" "/data/shared"',
          'chmod 775 "/data/shared"',
        ]);
      });
    });

    describe('setupWorktreesDir', () => {
      it('returns array of directory setup commands', () => {
        const cmds = UnixUserCommands.setupWorktreesDir('alice');
        expect(cmds).toEqual([
          'mkdir -p "/home/alice/agor/worktrees"',
          'chown -R "alice:alice" "/home/alice/agor"',
        ]);
      });
    });
  });

  // =========================================================================
  // Unix User Existence Check
  // =========================================================================

  describe('unixUserExists (mocked)', () => {
    // Note: These tests use mocked execSync since we can't create real users

    it('returns true when user exists', async () => {
      mockedExecSync.mockReturnValueOnce(Buffer.from('')); // Success (no throw)

      // Import fresh to use mock
      const { unixUserExists } = await import('./user-manager.js');
      expect(unixUserExists('root')).toBe(true);
    });

    it('returns false when user does not exist', async () => {
      mockedExecSync.mockImplementationOnce(() => {
        throw new Error('id: nonexistent: no such user');
      });

      const { unixUserExists } = await import('./user-manager.js');
      expect(unixUserExists('nonexistent_user_xyz')).toBe(false);
    });
  });

  // =========================================================================
  // Impersonation Resolution Logic
  // =========================================================================

  describe('resolveUnixUserForImpersonation', () => {
    describe('simple mode', () => {
      it('returns null user (no impersonation)', () => {
        const result = resolveUnixUserForImpersonation({
          mode: 'simple',
          userUnixUsername: 'alice',
          executorUnixUser: 'executor',
        });

        expect(result.unixUser).toBeNull();
        expect(result.reason).toContain('simple mode');
      });
    });

    describe('insulated mode', () => {
      it('uses executor user when configured', () => {
        const result = resolveUnixUserForImpersonation({
          mode: 'insulated',
          userUnixUsername: 'alice',
          executorUnixUser: 'agor_executor',
        });

        expect(result.unixUser).toBe('agor_executor');
        expect(result.reason).toContain('insulated');
        expect(result.reason).toContain('agor_executor');
      });

      it('returns null when no executor configured', () => {
        const result = resolveUnixUserForImpersonation({
          mode: 'insulated',
          userUnixUsername: 'alice',
          executorUnixUser: undefined,
        });

        expect(result.unixUser).toBeNull();
        expect(result.reason).toContain('no executor configured');
      });

      it('ignores user unix_username entirely', () => {
        const result = resolveUnixUserForImpersonation({
          mode: 'insulated',
          userUnixUsername: 'alice',
          executorUnixUser: 'executor',
        });

        expect(result.unixUser).toBe('executor');
      });
    });

    describe('strict mode', () => {
      it('uses user unix_username when provided', () => {
        const result = resolveUnixUserForImpersonation({
          mode: 'strict',
          userUnixUsername: 'alice',
          executorUnixUser: 'executor',
        });

        expect(result.unixUser).toBe('alice');
        expect(result.reason).toContain('strict');
      });

      it('throws when no user unix_username provided', () => {
        expect(() =>
          resolveUnixUserForImpersonation({
            mode: 'strict',
            userUnixUsername: undefined,
            executorUnixUser: 'executor',
          })
        ).toThrow('Strict Unix user mode requires unix_username');
      });

      it('throws when user unix_username is null', () => {
        expect(() =>
          resolveUnixUserForImpersonation({
            mode: 'strict',
            userUnixUsername: null,
            executorUnixUser: 'executor',
          })
        ).toThrow('Strict Unix user mode requires unix_username');
      });

      it('does NOT check if user exists (validation is separate)', () => {
        // Note: strict mode just returns the username, validation is done separately
        const result = resolveUnixUserForImpersonation({
          mode: 'strict',
          userUnixUsername: 'nonexistent',
          executorUnixUser: undefined,
        });

        expect(result.unixUser).toBe('nonexistent');
      });
    });

    describe('unknown mode', () => {
      it('falls back to simple mode (no impersonation)', () => {
        const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});

        const result = resolveUnixUserForImpersonation({
          mode: 'invalid' as any,
          userUnixUsername: 'alice',
          executorUnixUser: 'executor',
        });

        expect(result.unixUser).toBeNull();
        expect(result.reason).toContain('unknown mode');
        expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Unknown unix_user_mode'));

        consoleSpy.mockRestore();
      });
    });
  });

  // =========================================================================
  // Validation of Resolved Unix User
  // =========================================================================

  describe('validateResolvedUnixUser', () => {
    it('does nothing for simple mode', () => {
      expect(() => validateResolvedUnixUser('simple', 'alice')).not.toThrow();
      expect(() => validateResolvedUnixUser('simple', null)).not.toThrow();
    });

    it('validates user exists for strict mode', () => {
      mockedExecSync.mockImplementationOnce(() => {
        throw new Error('no such user');
      });

      expect(() => validateResolvedUnixUser('strict', 'nonexistent')).toThrow(
        UnixUserNotFoundError
      );
    });

    it('validates user exists for insulated mode', () => {
      mockedExecSync.mockImplementationOnce(() => {
        throw new Error('no such user');
      });

      expect(() => validateResolvedUnixUser('insulated', 'nonexistent')).toThrow(
        UnixUserNotFoundError
      );
    });

    it('does not throw for null user in strict/insulated mode', () => {
      // If unixUser is null, nothing to validate
      expect(() => validateResolvedUnixUser('strict', null)).not.toThrow();
      expect(() => validateResolvedUnixUser('insulated', null)).not.toThrow();
    });

    it('passes when user exists', () => {
      mockedExecSync.mockReturnValueOnce(Buffer.from('')); // user exists

      expect(() => validateResolvedUnixUser('strict', 'alice')).not.toThrow();
    });

    it('error message includes mode context', () => {
      mockedExecSync.mockImplementationOnce(() => {
        throw new Error('no such user');
      });

      try {
        validateResolvedUnixUser('strict', 'alice');
        expect.fail('Should have thrown');
      } catch (err) {
        expect((err as Error).message).toContain('Strict');
        expect((err as Error).message).toContain('alice');
      }
    });
  });

  // =========================================================================
  // Constants
  // =========================================================================

  describe('constants', () => {
    it('AGOR_HOME_BASE is /home', () => {
      expect(AGOR_HOME_BASE).toBe('/home');
    });

    it('AGOR_DEFAULT_SHELL is /bin/bash', () => {
      expect(AGOR_DEFAULT_SHELL).toBe('/bin/bash');
    });

    it('AGOR_WORKTREES_DIR is agor/worktrees', () => {
      expect(AGOR_WORKTREES_DIR).toBe('agor/worktrees');
    });
  });
});
